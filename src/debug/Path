    Definition t : Type := list(nat) * ZExp.cursor_side.

    Definition cons' (step : nat) (r : t) : t := 
        match r with (steps, side) => (cons step steps, side) end. 

    Fixpoint of_ztyp (zty : ZTyp.t) : t := 
      match zty with 
      | ZTyp.CursorT cursor_side _ => (nil, cursor_side)
      | ZTyp.ParenthesizedZ zty1 => cons' O (of_ztyp zty1)
      | ZTyp.ListZ zty1 => cons' O (of_ztyp zty1)
      | ZTyp.OpSeqZ _ zty1 surround => 
        let n := OperatorSeq.surround_prefix_length surround in 
        cons' n (of_ztyp zty1)
      end.

    Fixpoint of_zpat (zp : ZPat.t) : t := 
      match zp with 
      | ZPat.CursorP cursor_side _ => (nil, cursor_side)
      | ZPat.Deeper _ zp' => of_zpat' zp'
      | ZPat.ParenthesizedZ zp1 => cons' 0 (of_zpat zp1)
      end
    with of_zpat' (zp' : ZPat.t') : t := 
      match zp' with 
      | ZPat.InjZ _ zp1 => cons' 0 (of_zpat zp1)
      (* | ZPat.ListLitZ zps => 
        let prefix_length := ZList.prefix_length zps in 
        let zp0 := ZList.prj_z zps in 
        cons' prefix_length (of_zpat zp0) *)
      | ZPat.OpSeqZ _ zp1 surround => 
        let n := OperatorSeq.surround_prefix_length surround in 
        cons' n (of_zpat zp1)
      end. 

    Fixpoint of_zexp (ze : ZExp.t) : t := 
      match ze with 
      | ZExp.CursorE cursor_side _ => (nil, cursor_side)
      | ZExp.Deeper _ ze' => of_zexp' ze'
      | ZExp.ParenthesizedZ ze1 => cons' O (of_zexp ze1)
      end
    with of_zexp' (ze : ZExp.t') : t := 
      match ze with 
      | ZExp.AscZ1 ze' _ => cons' O (of_zexp ze')
      | ZExp.AscZ2 _ zty => cons' 1 (of_ztyp zty)
      | ZExp.LetZP zp _ _ _ => cons' O (of_zpat zp) 
      | ZExp.LetZA _ zann _ _ => cons' 1 (of_ztyp zann)
      | ZExp.LetZE1 _ _ ze1 _ => cons' 2 (of_zexp ze1) 
      | ZExp.LetZE2 _ _ _ ze2 => cons' 3 (of_zexp ze2)
      | ZExp.LamZP zp _ _ => cons' O (of_zpat zp)
      | ZExp.LamZA _ zann _ => cons' 1 (of_ztyp zann)
      | ZExp.LamZE _ ann ze' => cons' 2 (of_zexp ze')
      | ZExp.InjZ _ ze' => cons' O (of_zexp ze')
      (* | ZExp.ListLitZ zes => 
        let prefix_length := ZList.prefix_length zes in 
        let ze0 := ZList.prj_z zes in 
        cons' prefix_length (of_zexp ze0) *)
      | ZExp.CaseZE ze1 _ => cons' O (of_zexp ze1)
      | ZExp.CaseZR _ zrules => 
        let prefix_len := List.length (ZList.prj_prefix zrules) in 
        let zrule := ZList.prj_z zrules in 
        cons' (S prefix_len) (of_zrule zrule) 
      | ZExp.OpSeqZ _ ze' surround => 
        let n := OperatorSeq.surround_prefix_length surround in 
        cons' n (of_zexp ze')
      | ZExp.ApPaletteZ _ _ zholedata => 
        let (_, zholemap) := zholedata in 
        let (_, tz) := zholemap in 
        let (n, tz') := tz in
        let (_, ze') := tz' in 
        cons' n (of_zexp ze')
      end
    with of_zrule (zrule : ZExp.zrule) : t := 
      match zrule with 
      | ZExp.RuleZP zp _ => cons' O (of_zpat zp)
      | ZExp.RuleZE _ ze => cons' 1 (of_zexp ze)
      end.

    Definition of_OpSeqZ (ze : ZExp.t) (surround : ZExp.opseq_surround) := 
      let n := OperatorSeq.surround_prefix_length surround in 
      cons' n (of_zexp ze).

    Definition of_OpSeqZ_pat (zp : ZPat.t) (surround : ZPat.opseq_surround) := 
      let n := OperatorSeq.surround_prefix_length surround in 
      cons' n (of_zpat zp).

    Fixpoint follow_ty (fuel : Fuel.t) (path : t) (uty : UHTyp.t) : option(ZTyp.t) := 
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      match path with
      | (nil, cursor_side) => Some (ZTyp.CursorT cursor_side uty)
      | (cons x xs, cursor_side) => 
        match uty with 
        | UHTyp.Hole
        | UHTyp.Unit
        | UHTyp.Num
        | UHTyp.Bool => None
        | UHTyp.Parenthesized uty1 => 
          match x with 
          | O => 
            match follow_ty fuel (xs, cursor_side) uty1 with 
            | Some zty => Some (ZTyp.ParenthesizedZ zty)
            | None => None
            end
          | _ => None
          end
        | UHTyp.List uty1 => 
          match x with 
          | O => 
            match follow_ty fuel (xs, cursor_side) uty1 with 
            | None => None
            | Some zty => Some (ZTyp.ListZ zty)
            end
          | _ => None
          end
        | UHTyp.OpSeq skel seq => 
          match OperatorSeq.split x seq with 
          | Some (uty_n, surround) => 
            match follow_ty fuel (xs, cursor_side) uty_n with 
            | Some zty_n => 
              Some (ZTyp.OpSeqZ skel zty_n surround)
            | None => None
            end
          | None => None
          end
        end
      end
      end.

    Fixpoint follow_pat (fuel : Fuel.t) (path : t) (p : UHPat.t) : option(ZPat.t) := 
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      let follow_pat := follow_pat fuel in  
      match path with 
      | (nil, cursor_side) => Some (ZPat.CursorP cursor_side p)
      | (cons x xs, cursor_side) => 
        match p with 
        | UHPat.Parenthesized p1 => 
          match x with 
          | 0 => 
            match follow_pat (xs, cursor_side) p1 with 
            | None => None
            | Some zp1 => Some (ZPat.ParenthesizedZ zp1)
            end
          | _ => None
          end
        | UHPat.Pat err_status p' => 
          match (x, p') with 
          | (_, UHPat.EmptyHole _)
          | (_, UHPat.Wild)
          | (_, UHPat.Var _)
          | (_, UHPat.NumLit _)
          | (_, UHPat.BoolLit _)
          | (_, UHPat.ListNil) => None
          (* | (n, UHPat.ListLit ps) => 
            match ZList.split_at n ps with 
            | None => None
            | Some psz => 
              match ZList.optmap_z (follow_pat (xs, cursor_side)) psz with 
              | None => None
              | Some zps => 
                Some (ZPat.Deeper err_status (ZPat.ListLitZ zps))
              end
            end *)
          | (0, UHPat.Inj side p1) => 
            match follow_pat (xs, cursor_side) p1 with 
            | None => None
            | Some zp1 => Some (ZPat.Deeper err_status (ZPat.InjZ side zp1))
            end
          | (_, UHPat.Inj _ _) => None
          | (n, UHPat.OpSeq skel seq) => 
            match OperatorSeq.split n seq with 
            | None => None
            | Some (p, surround) => 
                match follow_pat (xs, cursor_side) p with 
                | Some zp => 
                    Some (ZPat.Deeper err_status (ZPat.OpSeqZ skel zp surround))
                | None => None
                end
            end
          end
        end
      end
      end.

    Fixpoint follow_e (fuel : Fuel.t) (path : t) (e : UHExp.t) : option(ZExp.t) := 
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      let follow_e := follow_e fuel in  
      match path with 
      | (nil, cursor_side) => Some (ZExp.CursorE cursor_side e)
      | (cons x xs, cursor_side) => 
        match e with 
        | UHExp.Parenthesized e1 => 
          match x with 
          | O => 
            match follow_e (xs, cursor_side) e1 with 
            | Some ze1 => Some (ZExp.ParenthesizedZ ze1)
            | None => None
            end
          | _ => None
          end
        | UHExp.Tm err_status e => 
          match (x, e) with 
          | (_, UHExp.EmptyHole _) => None
          | (O, UHExp.Asc e1 ty) => 
            match follow_e (xs, cursor_side) e1 with 
            | Some ze => Some (ZExp.Deeper err_status (ZExp.AscZ1 ze ty))
            | None => None
            end
          | (1, UHExp.Asc e1 ty) => 
            match follow_ty fuel (xs, cursor_side) ty with 
            | Some ztau => Some (ZExp.Deeper err_status (ZExp.AscZ2 e1 ztau))
            | None => None
            end
          | (_, UHExp.Asc _ _) => None
          | (_, UHExp.Var _ _) => None
          | (O, UHExp.Let p ann e1  e2) => 
            match follow_pat fuel (xs, cursor_side) p with 
            | None => None
            | Some zp => 
              Some (ZExp.Deeper err_status (ZExp.LetZP zp ann e1 e2))
            end
          | (1, UHExp.Let p ann e1 e2) => 
            match ann with 
            | None => None
            | Some ann_ty => 
              match follow_ty fuel (xs, cursor_side) ann_ty with 
              | None => None
              | Some zann => Some (ZExp.Deeper err_status (ZExp.LetZA p zann e1 e2)) 
              end
            end
          | (2, UHExp.Let p ann e1 e2) => 
            match follow_e (xs, cursor_side) e1 with 
            | Some ze1 => Some (ZExp.Deeper err_status (ZExp.LetZE1 p ann ze1 e2))
            | None => None
            end
          | (3, UHExp.Let p ann e1 e2) => 
            match follow_e (xs, cursor_side) e2 with 
            | Some ze2 => Some (ZExp.Deeper err_status (ZExp.LetZE2 p ann e1 ze2))
            | None => None
            end
          | (_, UHExp.Let _ _ _ _) => None
          | (O, UHExp.Lam p ann e1) => 
            match follow_pat fuel (xs, cursor_side) p with 
            | None => None
            | Some zp => 
              Some (ZExp.Deeper err_status (ZExp.LamZP zp ann e1))
            end
          | (1, UHExp.Lam p ann e1) => 
            match ann with 
            | None => None
            | Some ann_ty => 
              match follow_ty fuel (xs, cursor_side) ann_ty with 
              | None => None
              | Some zann => 
                Some (ZExp.Deeper err_status (ZExp.LamZA p zann e1))
              end
            end
          | (2, UHExp.Lam p ann e1) => 
            match follow_e (xs, cursor_side) e1 with 
            | None => None
            | Some ze => Some (ZExp.Deeper err_status (ZExp.LamZE p ann ze))
            end
          | (_, UHExp.Lam _ _ _) => None
          | (_, UHExp.NumLit _) => None
          | (_, UHExp.BoolLit _) => None
          | (O, UHExp.Inj side e1) => 
            match follow_e (xs, cursor_side) e1 with 
            | Some ze => Some (ZExp.Deeper err_status (ZExp.InjZ side ze))
            | None => None
            end
          | (_, UHExp.Inj _ _) => None
          | (_, UHExp.ListNil) => None
          (* | (n, UHExp.ListLit es) => 
            match ZList.split_at n es with 
            | None => None
            | Some esz => 
              match ZList.optmap_z (follow_e (xs, cursor_side)) esz with 
              | None => None
              | Some zes => 
                Some (ZExp.Deeper err_status (ZExp.ListLitZ zes))
              end
            end *)
          | (O, UHExp.Case e1 rules) => 
            match follow_e (xs, cursor_side) e1 with 
            | Some ze => Some (ZExp.Deeper err_status (ZExp.CaseZE ze rules))
            | None => None
            end
          | (S x, UHExp.Case e1 rules) => 
            match ZList.split_at x rules with 
            | None => None
            | Some split_rules => 
              match ZList.optmap_z (follow_rule fuel (xs, cursor_side)) split_rules with 
              | None => None
              | Some zrules => 
                Some (ZExp.Deeper err_status (ZExp.CaseZR e1 zrules))
              end
            end
          | (n, UHExp.OpSeq skel seq) => 
            match OperatorSeq.split n seq with 
            | Some (e, surround) => 
                match follow_e (xs, cursor_side) e with 
                | Some ze => 
                    Some (ZExp.Deeper err_status (ZExp.OpSeqZ skel ze surround))
                | None => None
                end
            | None => None
            end
          | (hole_ref, UHExp.ApPalette name serialized_model hole_data) => 
            let (next_hole_ref, holemap) := hole_data in 
            match NatMap.drop holemap hole_ref with
            | None => None
            | Some (holemap', te) =>
              let (ty, e') := te in 
              match follow_e (xs, cursor_side) e' with 
              | None => None
              | Some ze => 
                let zholemap := (holemap', (hole_ref, (ty, ze))) in 
                let zholedata := (next_hole_ref, zholemap) in 
                Some (ZExp.Deeper NotInHole (ZExp.ApPaletteZ name serialized_model zholedata))
              end
            end
          end
        end
      end
      end
    with follow_rule (fuel : Fuel.t) (path : t) (rule : UHExp.rule) : option(ZExp.zrule) := 
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      match rule with 
      | UHExp.Rule p e => 
        match path with 
        | (nil, _) => None
        | (cons 0 xs, cursor_side) => 
          match follow_pat fuel (xs, cursor_side) p with 
          | None => None
          | Some zp => Some (ZExp.RuleZP zp e)
          end
        | (cons 1 xs, cursor_side) => 
          match follow_e fuel (xs, cursor_side) e with 
          | None => None
          | Some ze => Some (ZExp.RuleZE p ze)
          end
        | (cons _ _, _) => None
        end
      end
      end.

    Definition cons_opt (n : nat) (x : option(list(nat))) : option(list(nat)) := 
      match x with 
      | None => None
      | Some xs => Some (cons n xs)
      end.

    Definition cons_opt2 
      (n1 : nat) (x1 : option(list(nat)))
      (n2 : nat) (x2 : unit -> option(list(nat)))
      : option(list(nat)) := 
        match x1 with 
        | Some xs => Some (cons n1 xs)
        | None => 
          match x2 tt with 
          | Some xs => Some (cons n2 xs)
          | None => None
          end
        end.

    Definition cons_opt3 
      (n1 : nat) (x1 : option(list(nat)))
      (n2 : nat) (x2 : unit -> option(list(nat)))
      (n3 : nat) (x3 : unit -> option(list(nat)))
      : option(list(nat)) := 
        match x1 with 
        | Some xs => Some (cons n1 xs)
        | None => 
          match x2 tt with 
          | Some xs => Some (cons n2 xs)
          | None => 
            match x3 tt with 
            | Some xs => Some (cons n3 xs)
            | None => None
            end
          end
        end.

    Fixpoint steps_to_hole_pat (fuel : Fuel.t) (p : UHPat.t) (u : MetaVar.t) : option(list(nat)) := 
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      match p with 
      | UHPat.Pat _ (UHPat.EmptyHole u') => 
        if MetaVar.eq u u' then 
          Some nil
        else None
      | UHPat.Parenthesized p1 => 
        cons_opt 0 (steps_to_hole_pat fuel p1 u)
      | UHPat.Pat _ UHPat.Wild
      | UHPat.Pat _ (UHPat.Var _) 
      | UHPat.Pat _ (UHPat.NumLit _) 
      | UHPat.Pat _ (UHPat.BoolLit _)
      | UHPat.Pat _ UHPat.ListNil => None
      (* | UHPat.Pat _ (UHPat.ListLit ps) => 
        Util.findmapi ps (fun i p => 
          match steps_to_hole_pat fuel p u with 
          | None => None
          | Some ns => Some (cons i ns)
          end) *)
      | UHPat.Pat _ (UHPat.Inj _ p1) => 
        cons_opt 0 (steps_to_hole_pat fuel p1 u)
      | UHPat.Pat _ (UHPat.OpSeq skel seq) => 
        steps_to_hole_seq_pat fuel seq u  
      end
      end
    with steps_to_hole_seq_pat (fuel : Fuel.t) (seq : UHPat.opseq) (u : MetaVar.t) : option(list(nat)) :=  
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      match seq with 
      | OperatorSeq.ExpOpExp p1 _ p2 => 
        cons_opt2
          0 (steps_to_hole_pat fuel p1 u)
          1 (fun _ => steps_to_hole_pat fuel p2 u)
      | OperatorSeq.SeqOpExp seq1 op p1 => 
        match steps_to_hole_seq_pat fuel seq1 u with 
        | (Some steps) as path => path
        | None => cons_opt (OperatorSeq.seq_length seq1) (steps_to_hole_pat fuel p1 u)
        end
      end
      end.

    Fixpoint steps_to_hole (fuel : Fuel.t) (e : UHExp.t) (u : MetaVar.t) : option(list(nat)) := 
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      match e with 
      | UHExp.Tm _ (UHExp.EmptyHole u') => 
        if MetaVar.eq u u' then 
          Some nil
        else None
      | UHExp.Parenthesized e1 =>   
        cons_opt O (steps_to_hole fuel e1 u)
      | UHExp.Tm _ (UHExp.Var _ _)
      | UHExp.Tm _ (UHExp.NumLit _)
      | UHExp.Tm _ (UHExp.BoolLit _) => None
      | UHExp.Tm _ (UHExp.Asc e1 _)  
      | UHExp.Tm _ (UHExp.Inj _ e1) => 
        cons_opt O (steps_to_hole fuel e1 u)
      | UHExp.Tm _ UHExp.ListNil => None
      (* | UHExp.Tm _ (UHExp.ListLit es) => 
        Util.findmapi es (fun i e => 
          match steps_to_hole fuel e u with 
          | None => None
          | Some ns => Some (cons i ns)
          end) *)
      | UHExp.Tm _ (UHExp.Lam p _ e1) => 
        cons_opt2 
          0 (steps_to_hole_pat fuel p u)
          2 (fun _ => steps_to_hole fuel e1 u)
      | UHExp.Tm _ (UHExp.Let p ann e1 e2) => 
        cons_opt3 
          0 (steps_to_hole_pat fuel p u)
          2 (fun _ => steps_to_hole fuel e1 u)
          3 (fun _ => steps_to_hole fuel e2 u)
      | UHExp.Tm _ (UHExp.Case e1 rules) => 
        match steps_to_hole fuel e1 u with 
        | Some steps => Some (cons 0 steps) 
        | None => 
          Util.findmapi rules (
            fun i rule => 
              match rule with 
              | UHExp.Rule p e => 
                match steps_to_hole_pat fuel p u with 
                | Some steps => Some (cons (S i) (cons 0 steps))
                | None => 
                  match steps_to_hole fuel e u with 
                  | Some steps => Some (cons (S i) (cons 1 steps))
                  | None => None
                  end
                end
              end) 
        end
      | UHExp.Tm _ (UHExp.OpSeq skel seq) => 
        steps_to_hole_seq fuel seq u  
      | UHExp.Tm _ (UHExp.ApPalette _ _ holedata) => 
        let (_, holemap) := holedata in 
        NatMap.fold holemap (fun c v => 
          match c with 
          | Some _ => c
          | None => 
            let (_, te) := v in
            let (_, e) := te in 
            steps_to_hole fuel e u 
          end
        ) None
      end
      end
    with steps_to_hole_seq (fuel : Fuel.t) (seq : UHExp.opseq) (u : MetaVar.t) : option(list(nat)) :=  
      match fuel with 
      | Fuel.Kicked => None
      | Fuel.More fuel => 
      match seq with 
      | OperatorSeq.ExpOpExp e1 _ e2 => 
        cons_opt2
          0 (steps_to_hole fuel e1 u)
          1 (fun _ => steps_to_hole fuel e2 u)
      | OperatorSeq.SeqOpExp seq1 op e1 => 
        match steps_to_hole_seq fuel seq1 u with 
        | (Some steps) as path => path
        | None => cons_opt (OperatorSeq.seq_length seq1) (steps_to_hole fuel e1 u)
        end
      end
      end.

    Definition path_to_hole (fuel : Fuel.t) (e : UHExp.t) (u : MetaVar.t) : option(t) := 
      match steps_to_hole fuel e u with 
      | Some steps => Some (steps, Before)
      | None => None
      end.

    Fixpoint first_hole_steps_ty (fuel : Fuel.t) (uty : UHTyp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match uty with
      | UHTyp.Parenthesized uty' => cons_opt O (first_hole_steps_ty fuel uty')
      | UHTyp.Unit
      | UHTyp.Num 
      | UHTyp.Bool => None
      | UHTyp.Hole => Some nil
      | UHTyp.List uty1 => cons_opt 0 (first_hole_steps_ty fuel uty1)
      | UHTyp.OpSeq _ opseq => first_hole_steps_ty_opseq fuel opseq 0
      end
      end
    (* return an optional path of the first hole in opseq starting with the nth term *)
    with first_hole_steps_ty_opseq (fuel : Fuel.t) (opseq : OperatorSeq.opseq UHTyp.t UHTyp.op) (n : nat) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
        if Nat.leb (OperatorSeq.seq_length opseq) n
        then None
        else
          match OperatorSeq.seq_nth n opseq with
          | None => None (* degenerate case *)
          | Some uty' =>
            match first_hole_steps_ty fuel uty' with
            | Some ns => Some (cons n ns)
            | None => first_hole_steps_ty_opseq fuel opseq (n+1)
            end
          end
      end.

    Fixpoint first_hole_steps_pat (fuel : Fuel.t) (p : UHPat.t) : option(list nat) := 
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match p with 
      | UHPat.Parenthesized p1 => cons_opt 0 (first_hole_steps_pat fuel p1)
      | UHPat.Pat _ (UHPat.EmptyHole _) => Some nil
      | UHPat.Pat _ UHPat.Wild
      | UHPat.Pat _ (UHPat.Var _)
      | UHPat.Pat _ (UHPat.NumLit _) 
      | UHPat.Pat _ (UHPat.BoolLit _) => None
      | UHPat.Pat _ (UHPat.Inj _ p1) => cons_opt 0 (first_hole_steps_pat fuel p1)
      | UHPat.Pat _ UHPat.ListNil => None
      (* | UHPat.Pat _ (UHPat.ListLit ps) => 
        Util.findmapi ps (fun i p => 
          match first_hole_steps_pat fuel p with 
          | None => None
          | Some ns => Some (cons i ns)
          end) *)
      | UHPat.Pat _ (UHPat.OpSeq _ seq) => first_hole_steps_opseq_pat fuel seq 0
      end
      end
    with first_hole_steps_opseq_pat (fuel : Fuel.t) (opseq : UHPat.opseq) (n : nat) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
        if Nat.leb (OperatorSeq.seq_length opseq) n
        then None
        else
          match OperatorSeq.seq_nth n opseq with
          | None => None
          | Some ue =>
            match first_hole_steps_pat fuel ue with
            | Some ns => Some (cons n ns)
            | None => first_hole_steps_opseq_pat fuel opseq (n+1)
            end
          end
      end.

    Fixpoint first_hole_steps (fuel : Fuel.t) (ue : UHExp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match ue with
      | UHExp.Parenthesized ue1 => cons_opt 0 (first_hole_steps fuel ue1)
      | UHExp.Tm _ ue' =>
        match ue' with
        | UHExp.EmptyHole _ => Some nil
        | UHExp.Asc ue1 uty =>
          cons_opt2 
            0 (first_hole_steps fuel ue1)
            1 (fun _ => first_hole_steps_ty fuel uty)
        | UHExp.Var _ _ => None
        | UHExp.Let p ann ue1 ue2 =>
          match first_hole_steps_pat fuel p with 
          | Some ns => Some (cons 0 ns)
          | None => 
            match ann with 
            | Some ann_ty => 
              cons_opt3 
                1 (first_hole_steps_ty fuel ann_ty)
                2 (fun _ => first_hole_steps fuel ue1)
                3 (fun _ => first_hole_steps fuel ue2)
            | None => 
              cons_opt2
                2 (first_hole_steps fuel ue1)
                3 (fun _ => first_hole_steps fuel ue2)
            end
          end
        | UHExp.Lam p ann e1 => 
          match first_hole_steps_pat fuel p with 
          | Some ns => Some (cons 0 ns)
          | None => 
            match ann with 
            | Some uty => 
              cons_opt2 
                1 (first_hole_steps_ty fuel uty)
                2 (fun _ => first_hole_steps fuel e1)
            | None => cons_opt 2 (first_hole_steps fuel e1)
            end
          end
        | UHExp.NumLit _ => None
        | UHExp.BoolLit _ => None
        | UHExp.ListNil => None
        (* | UHExp.ListLit es => 
          Util.findmapi es (fun i e => 
            match first_hole_steps fuel e with 
            | None => None
            | Some ns => Some (cons i ns)
            end) *)
        | UHExp.Inj _ e1 => cons_opt 0 (first_hole_steps fuel e1)
        | UHExp.Case e1 rules =>
          match first_hole_steps fuel e1 with
          | Some ns => Some (cons 0 ns)
          | None => first_hole_steps_rules fuel rules
          end
        | UHExp.OpSeq _ opseq => first_hole_steps_opseq fuel opseq 0
        | UHExp.ApPalette _ _ _ => None (* TODO figure out tab order protocol *)
        end
      end
      end
    with first_hole_steps_rules (fuel : Fuel.t) (rules : UHExp.rules) : option (list nat) := 
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
        Util.findmapi rules (
          fun i rule => 
            match rule with 
            | UHExp.Rule p e => 
              match first_hole_steps_pat fuel p with 
              | Some ns => Some (cons (S i) (cons 0 ns))
              | None => 
                match first_hole_steps fuel e with 
                | Some ns => Some (cons (S i) (cons 1 ns))
                | None => None
                end
              end
            end)
      end
    (* return an optional path of the first hole in opseq starting with the nth term )*)
    with first_hole_steps_opseq (fuel : Fuel.t) (opseq : OperatorSeq.opseq UHExp.t UHExp.op) (n : nat) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
        if Nat.leb (OperatorSeq.seq_length opseq) n
        then None
        else
          match OperatorSeq.seq_nth n opseq with
          | None => None
          | Some ue =>
            match first_hole_steps fuel ue with
            | Some ns => Some (cons n ns)
            | None => first_hole_steps_opseq fuel opseq (n+1)
            end
          end
      end.

    Fixpoint next_hole_steps_ty (fuel : Fuel.t) (zty : ZTyp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match zty with
      | ZTyp.CursorT cursor_side uty =>
        match cursor_side, uty with
        | _, UHTyp.Hole => None
        | Before, _ => first_hole_steps_ty fuel uty
        | After, _ => None
        | In _, _ => None
        end
      | ZTyp.ParenthesizedZ zty' => cons_opt 0 (next_hole_steps_ty fuel zty')
      | ZTyp.ListZ zty1 => cons_opt 0 (next_hole_steps_ty fuel zty1) 
      | ZTyp.OpSeqZ _ zty' surround =>
        let n := OperatorSeq.surround_prefix_length surround in
        match next_hole_steps_ty fuel zty' with
        | Some ns => Some (cons n ns)
        | None =>
          let uty' := ZTyp.erase zty' in
          let opseq := OperatorSeq.opseq_of_exp_and_surround uty' surround in
          first_hole_steps_ty_opseq fuel opseq (n+1)
        end
      end
      end.

    Fixpoint next_hole_path_ty (fuel : Fuel.t) (zty : ZTyp.t) : option Path.t :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match next_hole_steps_ty fuel zty with
      | None => None
      | Some path => Some (path, Before)
      end
      end.

    Fixpoint next_hole_steps_pat (fuel : Fuel.t) (zp : ZPat.t) : option(list nat) := 
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match zp with 
      | ZPat.ParenthesizedZ zp1 => cons_opt 0 (next_hole_steps_pat fuel zp1)
      | ZPat.CursorP cursor_side p => 
        match cursor_side, p with 
        | _, (UHPat.Pat _ (UHPat.EmptyHole _)) => None
        | After, _ => None
        | Before, _ => first_hole_steps_pat fuel p
        | In k, _ => 
          match p with 
          | UHPat.Parenthesized _ => None
          | UHPat.Pat err p' => 
            match p' with 
            | UHPat.Wild
            | UHPat.Var _
            | UHPat.NumLit _
            | UHPat.BoolLit _ 
            | UHPat.ListNil 
            (* | UHPat.ListLit _ *)
            | UHPat.OpSeq _ _ => None
            | UHPat.Inj _ p1 => first_hole_steps_pat fuel p1 
            | UHPat.EmptyHole _ => None
            end
          end
        end
      | ZPat.Deeper _ (ZPat.InjZ _ zp1) => cons_opt 0 (next_hole_steps_pat fuel zp1)
      (* | ZPat.Deeper _ (ZPat.ListLitZ zps) => 
        let prefix_length := ZList.prefix_length zps in 
        let zp0 := ZList.prj_z zps in 
        match next_hole_steps_pat fuel zp0 with 
        | Some ns => 
          Some (cons prefix_length ns)
        | None =>
          let suffix := ZList.prj_suffix zps in 
          Util.findmapi suffix (fun i p => 
            match first_hole_steps_pat fuel p with 
            | None => None
            | Some ns => Some (cons (prefix_length + i + 1) ns)
            end)
        end *)
      | ZPat.Deeper _ (ZPat.OpSeqZ _ zp1 surround) =>
        let n := OperatorSeq.surround_prefix_length surround in
        match next_hole_steps_pat fuel zp1 with
        | Some ns => Some (cons n ns)
        | None =>
          let p := ZPat.erase zp1 in
          let opseq := OperatorSeq.opseq_of_exp_and_surround p surround in
          first_hole_steps_opseq_pat fuel opseq (n+1)
        end
      end
      end.

    Fixpoint next_hole_path_pat (fuel : Fuel.t) (zp : ZPat.t) : option Path.t :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match next_hole_steps_pat fuel zp with
      | None => None
      | Some path => Some (path, Before)
      end
      end.

    Fixpoint next_hole_steps (fuel : Fuel.t) (ze : ZExp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match ze with
      | ZExp.CursorE cursor_side ue =>
        match cursor_side, ue with
        | _, (UHExp.Tm _ (UHExp.EmptyHole _)) => None
        | After, _ => None
        | Before, _ => first_hole_steps fuel ue
        | In k, _ =>
          match ue with
          | UHExp.Parenthesized _ => None
          | UHExp.Tm err ue' =>
            match ue' with
            | UHExp.Asc _ uty => cons_opt 1 (first_hole_steps_ty fuel uty)
            | UHExp.Var _ _ => None
            | UHExp.Let p ann ue1 ue2 => 
              first_hole_steps fuel ue 
            | UHExp.Lam _ _ _ => 
              first_hole_steps fuel ue
            | UHExp.NumLit _
            | UHExp.BoolLit _
            | UHExp.ListNil 
            (* | UHExp.ListLit _ *) => None
            | UHExp.Inj _ ue'' => 
              first_hole_steps fuel ue 
            | UHExp.Case e1 rules => 
              match k with 
              | 0 => first_hole_steps fuel ue
              | 1 => None
              | _ => None
              end
            | UHExp.EmptyHole _ => None
            | UHExp.OpSeq _ _ => None
            | UHExp.ApPalette _ _ _ => None (* TODO move into palette holes *)
            end
          end
        end
      | ZExp.Deeper _ ze' =>
        match ze' with
        | ZExp.AscZ1 ze'' uty =>
          cons_opt2
            0 (next_hole_steps fuel ze'')
            1 (fun _ => first_hole_steps_ty fuel uty)
        | ZExp.AscZ2 _ zty => cons_opt 1 (next_hole_steps_ty fuel zty)
        | ZExp.LetZP zp ann ue1 ue2 => 
          match next_hole_steps_pat fuel zp with 
          | Some ns => Some (cons 0 ns)
          | None => 
            match ann with 
            | Some ann_ty => 
              cons_opt3 
                1 (first_hole_steps_ty fuel ann_ty) 
                2 (fun _ => first_hole_steps fuel ue1) 
                3 (fun _ => first_hole_steps fuel ue2)
            | None => 
              cons_opt2 
                2 (first_hole_steps fuel ue1)
                3 (fun _ => first_hole_steps fuel ue2)
            end
          end
        | ZExp.LetZA _ zann e1 e2 => 
          cons_opt3 
            1 (next_hole_steps_ty fuel zann)
            2 (fun _ => first_hole_steps fuel e1) 
            3 (fun _ => first_hole_steps fuel e2)
        | ZExp.LetZE1 _ _ ze1 e2 =>
          cons_opt2
            2 (next_hole_steps fuel ze1)
            3 (fun _ => first_hole_steps fuel e2)
        | ZExp.LetZE2 _ _ _ ze2 => 
          cons_opt 
            3 (next_hole_steps fuel ze2)
        | ZExp.LamZP zp ann e1 => 
          match next_hole_steps_pat fuel zp with 
          | Some ns => Some (cons 0 ns)
          | None => 
            match ann with 
            | Some uty => 
              cons_opt2 
                1 (first_hole_steps_ty fuel uty)
                2 (fun _ => first_hole_steps fuel e1)
            | None => 
               cons_opt 
                 2 (first_hole_steps fuel e1)
            end
          end
        | ZExp.LamZA _ zann e1 => 
          cons_opt2
            1 (next_hole_steps_ty fuel zann)
            2 (fun _ => first_hole_steps fuel e1)
        | ZExp.LamZE _ _ ze1 => 
          cons_opt 
            2 (next_hole_steps fuel ze1)
        | ZExp.InjZ _ ze'' => 
          cons_opt 
            0 (next_hole_steps fuel ze'')
        (* | ZExp.ListLitZ zes => 
          let prefix_length := ZList.prefix_length zes in 
          let ze0 := ZList.prj_z zes in 
          match next_hole_steps fuel ze0 with 
          | Some ns => 
            Some (cons prefix_length ns)
          | None =>
            let suffix := ZList.prj_suffix zes in 
            Util.findmapi suffix (fun i e => 
              match first_hole_steps fuel e with 
              | None => None
              | Some ns => Some (cons (prefix_length + i + 1) ns)
              end)
          end *)
        | ZExp.CaseZE ze1 rules =>
          match next_hole_steps fuel ze1 with
          | Some ns => Some (cons 0 ns)
          | None => first_hole_steps_rules fuel rules
          end
        | ZExp.CaseZR _ zrules => 
          let zr := ZList.prj_z zrules in 
          let prefix_len := List.length (ZList.prj_prefix zrules) in 
          match zr with 
          | ZExp.RuleZP zp e => 
            match next_hole_steps_pat fuel zp with 
            | Some ns => Some (cons (S prefix_len) (cons 0 ns))
            | None => 
              match first_hole_steps fuel e with 
              | Some ns => Some (cons (S prefix_len) (cons 1 ns))
              | None => 
                let suffix := ZList.prj_suffix zrules in 
                match first_hole_steps_rules fuel suffix with 
                | Some (cons offset ns) => Some (cons (prefix_len + offset + 1) ns)
                | Some nil => None (* should never happen *)
                | None => None
                end
              end
            end
          | ZExp.RuleZE _ ze => 
            match next_hole_steps fuel ze with 
            | Some ns => Some (cons (S prefix_len) (cons 1 ns))
            | None => 
              let suffix := ZList.prj_suffix zrules in 
              match first_hole_steps_rules fuel suffix with 
              | Some (cons offset ns) => Some (cons (prefix_len + offset + 1) ns)
              | Some nil => None (* should never happen *)
              | None => None
              end
            end
          end
        | ZExp.OpSeqZ _ ze'' surround =>
          let n := OperatorSeq.surround_prefix_length surround in
          match next_hole_steps fuel ze'' with
          | Some ns => Some (cons n ns)
          | None =>
            let ue'' := ZExp.erase ze'' in
            let opseq := OperatorSeq.opseq_of_exp_and_surround ue'' surround in
            first_hole_steps_opseq fuel opseq (n+1)
          end
        | ZExp.ApPaletteZ _ _ _ => None (* TODO figure out tab order protocol *)
        end
      | ZExp.ParenthesizedZ ze' => cons_opt 0 (next_hole_steps fuel ze')
      end
      end.

    Fixpoint next_hole_path (fuel : Fuel.t) (ze : ZExp.t) : option Path.t :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match next_hole_steps fuel ze with
      | None => None
      | Some path => Some (path, Before)
      end
      end.

    Fixpoint last_hole_steps_ty (fuel : Fuel.t) (uty : UHTyp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match uty with
      | UHTyp.Hole => Some nil
      | UHTyp.Parenthesized uty' => cons_opt 0 (last_hole_steps_ty fuel uty')
      | UHTyp.Unit
      | UHTyp.Num 
      | UHTyp.Bool => None
      | UHTyp.List uty1 => cons_opt 0 (last_hole_steps_ty fuel uty1)
      | UHTyp.OpSeq _ opseq => last_hole_steps_ty_opseq fuel opseq 0
      end
      end
    (* return an optional path of the last hole in opseq starting with the mth term from the end
       (e.g., the 0th and 1st term from the end of `1 + 2 + 3` are 3 and 2 respectively) *)
    with last_hole_steps_ty_opseq (fuel : Fuel.t) (opseq : OperatorSeq.opseq UHTyp.t UHTyp.op) (m : nat) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
        let l := OperatorSeq.seq_length opseq in
        if Nat.leb l m
        then None
        else
          let n := l-m-1 in
          match OperatorSeq.seq_nth n opseq with
          | None => None (* degenerate case *)
          | Some uty' =>
            match last_hole_steps_ty fuel uty' with
            | Some ns => Some (cons n ns)
            | None => last_hole_steps_ty_opseq fuel opseq (m+1)
            end
          end
      end.

    Fixpoint last_hole_steps_pat (fuel : Fuel.t) (p : UHPat.t) : option(list nat) := 
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match p with 
      | UHPat.Parenthesized p1 => cons_opt 0 (last_hole_steps_pat fuel p1)
      | UHPat.Pat _ (UHPat.EmptyHole _) => Some nil
      | UHPat.Pat _ UHPat.Wild
      | UHPat.Pat _ (UHPat.Var _)
      | UHPat.Pat _ (UHPat.NumLit _) 
      | UHPat.Pat _ (UHPat.BoolLit _) => None
      | UHPat.Pat _ (UHPat.Inj _ p1) => cons_opt 0 (last_hole_steps_pat fuel p1)
      | UHPat.Pat _ UHPat.ListNil => None
      (* | UHPat.Pat _ (UHPat.ListLit ps) => 
        let num_elts := List.length ps in 
        Util.findmapi ps (fun i p => 
          match last_hole_steps_pat fuel p with 
          | None => None
          | Some ns => Some (cons (num_elts - i - 1) ns)
          end) *)
      | UHPat.Pat _ (UHPat.OpSeq _ opseq) => last_hole_steps_opseq_pat fuel opseq 0
      end
      end
    with last_hole_steps_opseq_pat (fuel : Fuel.t) (opseq : UHPat.opseq) (m : nat) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
        let l := OperatorSeq.seq_length opseq in
        if Nat.leb l m
        then None
        else
          let n := l-m-1 in
          match OperatorSeq.seq_nth n opseq with
          | None => None
          | Some ue =>
            match last_hole_steps_pat fuel ue with
            | Some ns => Some (cons n ns)
            | None => last_hole_steps_opseq_pat fuel opseq (m+1)
            end
          end
      end.

    Fixpoint last_hole_steps (fuel : Fuel.t) (ue : UHExp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match ue with
      | UHExp.Parenthesized ue' => cons_opt 0 (last_hole_steps fuel ue')
      | UHExp.Tm _ ue' =>
        match ue' with
        | UHExp.EmptyHole _ => Some nil
        | UHExp.Asc ue0 uty1 =>
          cons_opt2 
            1 (last_hole_steps_ty fuel uty1)
            0 (fun _ => last_hole_steps fuel ue0)
        | UHExp.Var _ _ => None
        | UHExp.Let p ann e1 e2 =>
          match last_hole_steps fuel e2 with
          | Some ns => Some (cons 3 ns)
          | None => 
            match last_hole_steps fuel e1 with 
            | Some ns => Some (cons 2 ns) 
            | None => 
              match ann with 
              | Some ann_ty => 
                cons_opt2
                  1 (last_hole_steps_ty fuel ann_ty)
                  0 (fun _ => last_hole_steps_pat fuel p)
              | None => 
                cons_opt 0 (last_hole_steps_pat fuel p)
              end
            end 
          end
        | UHExp.Lam p ann e1 => 
          match last_hole_steps fuel e1 with
          | Some ns => Some (cons 2 ns)
          | None => 
            match ann with 
            | Some uty1 => 
              cons_opt2
                1 (last_hole_steps_ty fuel uty1)
                0 (fun _ => last_hole_steps_pat fuel p)
            | None => 
              cons_opt 0 (last_hole_steps_pat fuel p)
            end
          end
        | UHExp.NumLit _ 
        | UHExp.BoolLit _ => None
        | UHExp.Inj _ ue0 => cons_opt 0 (last_hole_steps fuel ue0)
        | UHExp.ListNil => None
        (* | UHExp.ListLit es => 
          let num_elts := List.length es in 
          Util.findmapi es (fun i e => 
            match last_hole_steps fuel e with 
            | None => None
            | Some ns => Some (cons (num_elts - i - 1) ns)
            end) *)
        | UHExp.Case e1 rules =>
          match last_hole_steps_rules fuel rules with 
          | (Some ns) as result => result
          | None => cons_opt 0 (last_hole_steps fuel e1)
          end
        | UHExp.OpSeq _ opseq => last_hole_steps_opseq fuel opseq 0
        | UHExp.ApPalette _ _ _ => None (* TODO figure out tab order protocol *)
        end
      end
      end
    with last_hole_steps_rules 
      (fuel : Fuel.t)
      (rules : UHExp.rules)
      : option(list nat) :=  
        match fuel with
        | Fuel.Kicked => None
        | Fuel.More fuel =>
          let n_rules := List.length rules in 
          Util.findmapi (List.rev rules) (
            fun i rule => 
              match rule with 
              | UHExp.Rule p e => 
                match last_hole_steps fuel e with 
                | Some ns => Some (cons (n_rules - i) (cons 1 ns))
                | None => 
                  match last_hole_steps_pat fuel p with 
                  | Some ns => Some (cons (n_rules - i) (cons 0 ns))
                  | None => None
                  end
                end
              end)
        end
    (* return an optional path of the last hole in opseq starting with the mth term from the end
       (e.g., the 0th and 1st term from the end of `1 + 2 + 3` are 3 and 2 respectively) *)
    with last_hole_steps_opseq (fuel : Fuel.t) (opseq : OperatorSeq.opseq UHExp.t UHExp.op) (m : nat) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
        let l := OperatorSeq.seq_length opseq in
        if Nat.leb l m
        then None
        else
          let n := l-m-1 in
          match OperatorSeq.seq_nth n opseq with
          | None => None
          | Some ue =>
            match last_hole_steps fuel ue with
            | Some ns => Some (cons n ns)
            | None => last_hole_steps_opseq fuel opseq (m+1)
            end
          end
      end.

    Fixpoint prev_hole_steps_ty (fuel : Fuel.t) (zty : ZTyp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match zty with
      | ZTyp.CursorT cursor_side uty =>
        match cursor_side, uty with
        | _, UHTyp.Hole => None
        | Before, _ => None
        | After, _ => last_hole_steps_ty fuel uty
        | In _, _ => None
        end
      | ZTyp.ParenthesizedZ zty' => cons_opt 0 (prev_hole_steps_ty fuel zty')
      | ZTyp.ListZ zty1 => cons_opt 0 (prev_hole_steps_ty fuel zty1)
      | ZTyp.OpSeqZ _ zty' surround =>
        let n := OperatorSeq.surround_prefix_length surround in
        match prev_hole_steps_ty fuel zty' with
        | Some ns => Some (cons n ns)
        | None =>
          let uty' := ZTyp.erase zty' in
          let opseq := OperatorSeq.opseq_of_exp_and_surround uty' surround in
          let m := OperatorSeq.surround_suffix_length surround in
          last_hole_steps_ty_opseq fuel opseq (m+1)
        end
      end
      end.

    Fixpoint prev_hole_path_ty (fuel : Fuel.t) (zty : ZTyp.t) : option Path.t :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match prev_hole_steps_ty fuel zty with
      | None => None
      | Some path => Some (path, Before)
      end
      end.

    Fixpoint prev_hole_steps_pat (fuel : Fuel.t) (zp : ZPat.t) : option(list nat) := 
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match zp with 
      | ZPat.ParenthesizedZ zp1 => cons_opt 0 (prev_hole_steps_pat fuel zp1)
      | ZPat.CursorP cursor_side p => 
        match cursor_side, p with 
        | _, (UHPat.Pat _ (UHPat.EmptyHole _)) => None
        | Before, _ => None
        | After, _ => last_hole_steps_pat fuel p
        | In k, _ => 
          match p with 
          | UHPat.Parenthesized _ => None
          | UHPat.Pat err p' => 
            match p' with 
            | UHPat.EmptyHole _ => None
            | UHPat.Wild
            | UHPat.Var _
            | UHPat.NumLit _
            | UHPat.BoolLit _
            | UHPat.ListNil 
            (* | UHPat.ListLit _ *) => None
            | UHPat.Inj _ p1 => None
            | UHPat.OpSeq _ _ => None
            end
          end
        end
      | ZPat.Deeper _ (ZPat.InjZ _ zp1) => cons_opt 0 (prev_hole_steps_pat fuel zp1)
      (* | ZPat.Deeper _ (ZPat.ListLitZ ((prefix, zp0), _)) => 
        let prefix_length := List.length prefix in 
        match prev_hole_steps_pat fuel zp0 with 
        | Some ns => Some (cons prefix_length ns)
        | None => last_hole_steps_pat fuel (UHPat.Pat NotInHole (UHPat.ListLit prefix))
        end *)
      | ZPat.Deeper _ (ZPat.OpSeqZ _ zp1 surround) => 
        let n := OperatorSeq.surround_prefix_length surround in
        match prev_hole_steps_pat fuel zp1 with
        | Some ns => Some (cons n ns)
        | None =>
          let ue_n := ZPat.erase zp1 in
          let opseq := OperatorSeq.opseq_of_exp_and_surround ue_n surround in
          let m := OperatorSeq.surround_suffix_length surround in
          last_hole_steps_opseq_pat fuel opseq (m+1)
        end
      end
      end.

    Fixpoint prev_hole_path_pat (fuel : Fuel.t) (zp : ZPat.t) : option Path.t :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match prev_hole_steps_pat fuel zp with
      | None => None
      | Some path => Some (path, Before)
      end
      end.

    Fixpoint prev_hole_steps (fuel : Fuel.t) (ze : ZExp.t) : option (list nat) :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match ze with
      | ZExp.CursorE cursor_side ue =>
        match cursor_side, ue with
        | _, (UHExp.Tm _ (UHExp.EmptyHole _)) => None
        | After, _ => last_hole_steps fuel ue
        | Before, _ => None
        | In k, _ =>
          match ue with
          | UHExp.Parenthesized _ => None (* cannot be In Parenthesized term *)
          | UHExp.Tm err ue' =>
            match ue' with
            | UHExp.Asc ue'' _ => cons_opt 0 (last_hole_steps fuel ue'')
            | UHExp.Var _ _ => None
            | UHExp.Let _ _ _ _ => None
            | UHExp.Lam _ _ _ => None
            | UHExp.NumLit _
            | UHExp.BoolLit _
            | UHExp.ListNil 
            (* | UHExp.ListLit _ *) => None
            | UHExp.Inj _ _ => None
            | UHExp.Case _ _ => 
              match k with 
              | 0 => None
              | 1 => last_hole_steps fuel ue
              | _ => None
              end
            | UHExp.EmptyHole _ => None
            | UHExp.OpSeq _ _ => None
            | UHExp.ApPalette _ _ _ => None (* TODO *)
            end
          end
        end
      | ZExp.Deeper _ ze' =>
        match ze' with
        | ZExp.AscZ1 ze0 _ => 
          cons_opt 0 (prev_hole_steps fuel ze0)
        | ZExp.AscZ2 ue0 zty1 =>
          cons_opt2
            1 (prev_hole_steps_ty fuel zty1)
            0 (fun _ => last_hole_steps fuel ue0)
        | ZExp.LetZP zp _ _ _ => 
          cons_opt 0 (prev_hole_steps_pat fuel zp) 
        | ZExp.LetZA p zann _ _ => 
          cons_opt2
            1 (prev_hole_steps_ty fuel zann)
            0 (fun _ => last_hole_steps_pat fuel p)
        | ZExp.LetZE1 p ann ze1 _ => 
          match prev_hole_steps fuel ze1 with
          | Some ns => Some (cons 2 ns)
          | None => 
            match ann with 
            | Some ann_ty => 
              cons_opt2 
                1 (last_hole_steps_ty fuel ann_ty)
                0 (fun _ => last_hole_steps_pat fuel p)
            | None => 
              cons_opt 0 (last_hole_steps_pat fuel p)
            end
          end
        | ZExp.LetZE2 p ann e1 ze2 => 
          match prev_hole_steps fuel ze2 with
          | Some ns => Some (cons 3 ns)
          | None => 
            match last_hole_steps fuel e1 with 
            | Some ns => Some (cons 2 ns)
            | None => 
              match ann with 
              | Some ann_ty => 
                cons_opt2
                  1 (last_hole_steps_ty fuel ann_ty)
                  0 (fun _ => last_hole_steps_pat fuel p)
              | None => None
              end
            end
          end
        | ZExp.LamZP zp _ _ => prev_hole_steps_pat fuel zp 
        | ZExp.LamZA p zann _ => 
          cons_opt2 
            1 (prev_hole_steps_ty fuel zann)
            0 (fun _ => last_hole_steps_pat fuel p)
        | ZExp.LamZE p ann ze1 => 
          match prev_hole_steps fuel ze1 with 
          | Some ns => Some (cons 2 ns)
          | None => 
            match ann with 
            | Some uty1 => 
              cons_opt2 
                1 (last_hole_steps_ty fuel uty1)
                0 (fun _ => last_hole_steps_pat fuel p)
            | None => cons_opt 0 (last_hole_steps_pat fuel p)
            end
          end
        | ZExp.InjZ _ ze0 => cons_opt 0 (prev_hole_steps fuel ze0)
        (* | ZExp.ListLitZ ((prefix, ze0), _) => 
          let prefix_length := List.length prefix in 
          match prev_hole_steps fuel ze0 with 
          | Some ns => Some (cons prefix_length ns)
          | None => last_hole_steps fuel (UHExp.Tm NotInHole (UHExp.ListLit prefix))
          end *)
        | ZExp.CaseZE ze rules => 
          cons_opt 0 (prev_hole_steps fuel ze)
        | ZExp.CaseZR e1 zrules => 
          let zr := ZList.prj_z zrules in 
          let prefix := ZList.prj_prefix zrules in 
          let prefix_len := List.length prefix in 
          match zr with 
          | ZExp.RuleZP zp e => 
            match prev_hole_steps_pat fuel zp with 
            | Some ns => Some (cons (S prefix_len) (cons 0 ns)) 
            | None =>
              match last_hole_steps_rules fuel prefix with
              | Some ns => Some ns
              | None => Path.cons_opt 0 (last_hole_steps fuel e1)
              end
            end
          | ZExp.RuleZE p ze => 
            match prev_hole_steps fuel ze with 
            | Some ns => Some (cons (S prefix_len) (cons 1 ns))
            | None => 
              match last_hole_steps_pat fuel p with 
              | Some ns => Some (cons (S prefix_len) (cons 0 ns))
              | None => 
                match last_hole_steps_rules fuel prefix with 
                | Some ns => Some ns
                | None => Path.cons_opt 0 (last_hole_steps fuel e1)
                end
              end
            end
          end
        | ZExp.OpSeqZ _ ze_n surround =>
          let n := OperatorSeq.surround_prefix_length surround in
          match prev_hole_steps fuel ze_n with
          | Some ns => Some (cons n ns)
          | None =>
            let ue_n := ZExp.erase ze_n in
            let opseq := OperatorSeq.opseq_of_exp_and_surround ue_n surround in
            let m := OperatorSeq.surround_suffix_length surround in
            last_hole_steps_opseq fuel opseq (m+1)
          end
        | ZExp.ApPaletteZ _ _ _ => None (* TODO figure out tab order protocol *)
        end
      | ZExp.ParenthesizedZ ze0 => cons_opt 0 (prev_hole_steps fuel ze0)
      end
      end.

    Fixpoint prev_hole_path (fuel : Fuel.t) (ze : ZExp.t) : option Path.t :=
      match fuel with
      | Fuel.Kicked => None
      | Fuel.More fuel =>
      match prev_hole_steps fuel ze with
      | None => None
      | Some path => Some (path, Before)
      end
      end.
